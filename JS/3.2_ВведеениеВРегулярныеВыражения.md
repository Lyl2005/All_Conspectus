# Регулярные выражения

Регулярное выражение (**RegExp - regular expressions**) - объект, который может описывать шаблон символов.

Например, если ищем в строке подстроку, то можем описать шаблон того, что ищем.

Простой шаблон может состоять даже из одного символа, большие и сложные шаблоны могут использоваться для парсинга, проверки формата введенных данных, замены и других различных целей.

Содержание шаблона регулярного выражения состоит из последовательности символов. Большая их часть (все буквы и цифры) описывают сами себя - непосредственно указывают свое присутствие. 

Например, регулярное выражение

```
/hello/
```

совпадет со всеми строками, в которых есть слово "hello". Другие символы обозначают не себя, а имеют некоторое модифицирующее значение.

Например, выражение
```
/hello$/
```
будет соответствовать строкам, которые **ЗАКАНЧИВАЮТСЯ** на слово "hello". Это обеспечивает метасимвол "$", обозначающий конец строки.
___

<br>

# Создание объектов RegExp

Объекты `RegExp` могут быть созданы с помощью конструктора `RegExp()`, или с помощью литералов. Но если, например, строковые литералы задаются в виде символов, заключенных в кавычки, то литералы регулярных выражений задаются заключенными в пару символов слэш  `/`. 

Например, вот так:

```JavaScript
var myPattern = /q$/;   //Создание регулярного выражения с помощью литерала
```

В данном примере создали c помощью литерала новый объект типа `RegExp` и присвоили его переменной `myPattern`. Данный шаблон соответствует любой строке, заканчивающейся символом **q**.

Cоздания объекта с помощью конструктора:

```JavaScript
var myPattern = new RegExp("q$");  //Создание регулярного выражения с помощью конструктора
```
___

<br>

Рассмотрим из чего можно составлять регулярные выражения.

Первая группа - **символы**. Все алфавитные и цифровые символы обозначают сами себя. Также можно вводить некоторые не алфавитные символы с помощью последовательностей, начинающихся с обратного слэша.

**Цифры и буквы** - соответствуют сами себе

+ `\0` - Символ **NUL** (Соответствует \u0000 в Unicode)
+ `\t` - Табуляция (\u0009)
+ `\n` - Перевод строки (\u000A)
+ `\v` - Вертикальная табуляция (\u000B)
+ `\f` - Перевод страницы (\u000C)
+ `\r` - Возврат каретки (\u000D)
+ `\xnn` - Символ из набора Latin, задаваемый шестнадцатиричным номером nn
+ `\unnnn` - Символ Unicode,  задаваемый шестнадцатиричным номером nnnn
+ `\cX` - Управляющий символ "Х", например \сJ эквивалентна \n

В регулярных выражениях также используются следующие символы:

```
^ $ . * + ? = ! : | \ / ( ) [ ] { }
```

> Необходимо запомнить, что для определения смысла этих символов буквально, т.е. "самих себя", необходимо перед ними ставить символ обратного слэша.

Если екобходимо написать регулярное выражение, по которому будет находиться символ обратного слэша, то мы должны в выражение поставить этот символ, предваряемый таким же символом обратного слэша. В результате такое регулярное выражение будет выглядеть следующим образом:

```
/\\/
```
___

<br>

# Классы

Отдельные символы могут быть объединены в классы. Это обозначается набором символов, заключенных в квадратные скобки. 

Например регулярное выражение

```JavaScript
/[0123456789]/
```
соответствует любой цифре.

Или же можно указав перед набором символов знак `^` определить регулярное выражение, которое будет соответствовать любому символу, **КРОМЕ** тех, которые указаны в скобках - класс с отрицанием.

Например выражение

```JavaScript
/[^0123456789]/
```

будет соответствовать любому символу **КРОМЕ** цифр.

<br>

Также в классах можно задавать диапазон с помощью знака дефиса `-`, чтобы не перечислять все символы. Например все цифры можно обозначить таким выражением:

```JavaScript
/[0-9]/
```

Некоторые классы из наборов символов настолько часто используются, что для них определили специальные обозначения:

+ `[...]` - любой из символов, указанных в скобках
+ `[^...]` - любой кроме символов, указанных в скобках
+ `.`(точка) - любой символ кроме перевода строки или другого разделителя строки
+ `\w` - эквивалентно [a-zA-Z0-9_] (Любой текстовый символ ASCII)
+ `\W` - эквивалентно [^a-zA-Z0-9_] (Любой символ кроме текстовых символов ASCII)
+ `\s` - любой пробельный символ из Unicode

+ `\S` - любой НЕпробельный символ из Unicode
+ `\d` - эквивалентно [0-9] (любые цифры ASCII)
+ `\D` - эквивалентно [^0-9] (все символы кроме цифр ASCII)
+ `[\b]` - обозначение символа "забой"

Последовательности таких управляющих символов также можно объединить в класс, например регулярное выражение

```
/[\w\s]/
```

соответствует любому пробельному символу или символу ASCII - букве или цифре.
___

<br>

# Квантификация (повторения)

Описанные выше шаблоны можно использовать не только для описания одиночных комбинаций символов, но и для сколь угодно многократных **повторений**. Это называют **`квантификацией`**.

**Для квантификации** в регулярных выражениях есть набор специальных комбинаций, заключаемых в фигурные скобки. Эта комбинация в фигурных скобках должна следовать сразу за описанным шаблоном. Например комбинация

```JavaScript
/\d{4}/     // соответствует числу, состоящему из 4-х цифр.
```

Рассмотрим какие бывают управляющие комбинации для повторений:

+ **{n}** - обозначает ровно n экземпляров шаблона
+ **{n,}** - обозначает n или больше экземпляров шаблона  
+ **{n,m}** -  обозначает не менее n и не более m экземпляров шаблона
+ **?** -  обозначает ноль или один экземпляр шаблона (эквивалентно выражению {0,1} )
+ **+** -  обозначает 1 или более экземпляров шаблона (эквивалентно выражению {1,} )
+ <b>*</b> -  обозначает ноль или более экземпляров шаблона (эквивалентно выражению {0,} )

Эти комбинации повторения соответствуют максимально возможному количеству совпадений. Например выражение

```JavaScript
/х{1,}/
```

примененное к строке "ххх" будет соответствовать максимальному количеству совпадений, т.е. всем трем буквам "х", встреченным в строке. Это называется "жадным" повторением ("жадной" квантификацией).

Если же мы хотим ограничить поиск первым же вхождением, то может использовать так называемую "нежадную", или "ленивую" квантификацию. Для этого после управляющей комбинации повторений ставится символ "?". Таким образом выражение

```JavaScript
/х{1,}?/ 
```
будет соответствовать только первому соответствию, т.е. только первой букве "х" в строке.

> Признак "ленивости" действует только на тот квантификатор (подшаблон) в шаблоне, после которого стоит, все остальные квантификаторы остаются "жадными".
___

<br>

# Альтернативы

Синтаксис регулярных выражений содержит специальный символ для определения `альтернативы`, т.е. можно указать больше одного варианта шаблона, соответствие которому будет проверяться.  Для разделения альтернатив используется символ `|`.

```JavaScript
/ma|pa|da/
```

будет соответствовать строке "ma" либо строке "pa" либо строке "da".

Альтернативы конечно также могут комбинироваться и с классами и с повторениями. Указанный ниже шаблон соответствует либо двум цифрам либо двум строчным буквам либо двум заглавным буквам:

```JavaScript
/\d{2}|[a-z]{2}|[A-Z]{2}/
```

**Важно!** альтернативы обрабатываются слева направо до первого соответствия. После нахождения первого соответствия остальные альтернативы будут игнорироваться. Например, шаблон /1|12|123/ примененный к строке "123", будет соответствовать первому символу, хотя в альтернативах есть гораздо более полное соответствие.

<br>

# Группировка

Группировка обозначается заключением подшаблона в круглые скобки ( ). При этом элементы, используемые совместно со специальными символами, например |, +, *, ? и другие, будут рассматриваться как одно целое.

Например шаблон

```JavaScript
/regular(expression)?/
```

будет соответствовать слову "regular" за которым следует необязательное слово "expression".

### **Пример** Использования подшаблона со специальными символами:
Выражение /123+ означает цифры 12, после которых следует любое количество повторения цифры 3, т.е. этому шаблону будут соответствовать значения 123, 1233, 12333 и так далее.
Если же мы заключим 123 в скобки, то + будет относиться ко всей группе, и этому шаблону будут соответствовать значения 123, 123123, 123123123 и т.д.
___

<br>

# Якорные выражения

Якорные выражения - указание границы соответствия.

Специальные символы используются для определения границ:

+ `^` - соответствует началу строки при многострочном поиске или началу строкового выражения
+ `$` - соответствует концу строки при многострочном поиске или концу строкового выражения
+ `\b` - соответствует границе слова, т.е. позиции между текстовым (aA-zZ) и не-текстовым символом, либо между текстовым символом и началом или концом строки.
+ `\B` - Соответствует позиции, не являющейся границей слов.
+ `(?=p)` - Позитивная опережающая проверка на последующие символы - убеждается в том, что последующие символы соответствуют шаблону "р" но не включает их в результат поиска.
+ `(?!p)` - Негативная опережающая проверка на последующие символы - требует чтобы последующие символы НЕ соответствовали шаблону "р".
___

<br>

# Флаги

Флаги задают глобальные правила для всего шаблона и указываются не внутри символов слэша, в которые заключен шаблон, а ПОСЛЕ них.

JavaScript поддерживает три варианта флагов:
+ `i` - указывает на то, что поиск по шаблону должен быть не чувствительным к регистру
+ `g` - указывает что поиск должен быть глобальным, т.е. должны быть найдены ВСЕ соответствия в строке
+ `m` - указывает на то, что поиск должен производиться в многострочном режиме.




