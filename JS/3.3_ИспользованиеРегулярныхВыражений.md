# Методы класса String

Сначала рассмотрим методы класса **String**, позволяющие использовать регулярные выражения:

+ `search(regexp)`
+ `replace(regexp, newString)`
+ `match(regexp)`
+ `split(divider)`

Метод `search()`

В качестве аргумента передается регулярное выражение, в ответ возвращает номер позиции, с которой найдено соответствие шаблону, если соответствие не найдено, то "-1".

```JavaScript
let myString = "This is just test string";
console.log(myString.search(/is/));         // 2
```

Два важных момента:
1. Метод `search()` не поддерживает глобальный поиск и флаг g в составе регулярного выражения будет игнорирован.

2.  Если аргумент не является регулярным выражением, то он будет преобразован в него передачей конструктору `RegExp`.

<br>

Метод `replace()`

С его помощью можно выполнить операцию поиска с заменой.
В качестве аргументов он принимает регулярное выражение и строку замены.

```JavaScript
let myString = "This is just test string";
console.log(myString.replace(/is/,"as"));   // "Thas is just test string"
```

Данный пример заменит первое найденное соответствие шаблону ("is") на подстроку "as".

Этот метод поддерживает глобальный поиск и при использовании флага `g` поменяет все найденные соответствия.

```JavaScript
console.log(myString.replace(/is/g,"us"));  // "Thus us just test string"
```

**Важно!**, что в качестве второго аргумента метода `replace()` может использоваться функция, в этом случае мы получим возможность динамического изменения строки замены.

> Если в качестве первого аргумента окажется **не регулярное выражение**, то он будет также как и у метода `search()` преобразован в регулярное выражение с помощью конструктора `RegExp`. А если, вовсе забыть указать второй аргумент, то будет произведена замена всех найденных совпадений на `undefined`

<br>

Метод `match()`

Он принимает в качестве аргумента регулярное выражение (или преобразовывает в него аргумент подобно предыдущим методам), а в качестве результата возвращает массив всех найденных соответствий.

```JavaScript
let str = "У дедушки в деревне было 12 яблонь, 5 кустов смородины, 10 кур и 33 коровы";
console.log(str.match(/\d{2}/g));       // ["12","10","33"]
```

В данном примере мы записали в регулярное выражение обозначение цифры `\d`, указали что ищем последовательность из двух цифр `{2}` и включили флаг глобального поиска `g`.

Eсли флаг глобального поиска не будет указан, то в массив попадет только первое совпадение, оно запишется нулевым элементом.

<br>

Метод `split()`

Он разбивает строку на массив подстрок, используя в качестве разделителя содержимое аргумента, которое в том числе может быть и регулярным выражением. Например, использовав в качестве разделителя два слэша можно отделить в веб-адресе протокол от собственно наименования сайта:

```JavaScript
let str = "http://www.example.com/download/pictures";
console.log(str.split(/\/{2}/g));       // ["http:","www.example.com/download/pictures"]
```

Таким же образом, например, можно разбить на массив строку состоящую из цифр:

```JavaScript
let str = "1234567890";
console.log(str.split(/\B/g));      // ["1","2","3","4","5","6","7","8","9","0"]
```

Используя в качестве разделителя определение символа, не являющегося границей слова
___

<br>

# Конструктор

Конструктор - метод, который принимает на вход некоторый аргумент, а на выходе создает объект необходимого вида.

Конструктор `RegExp` может принимать на вход строку, содержимое которой будет преобразовано в регулярное выражение. В строке должно быть содержимое регулярного выражения, т.е. тот текст, который обычно находится между двух слэшей.

```JavaScript
var myPattern = new RegExp("q$");        // Создаем шаблон, находящий букву "q" в конце строки
```

Также в конструктор можно передать второй, необязательный аргумент, в котором можно указать флаги. Например:

```JavaScript
var myPattern = new RegExp("q$","g");    // Создаем такой же шаблон, но добавляем флаг глобального поиска
```

> **Важно!** Если в тексте присутствует символ обратного слэша `\`, то его необходимо предварять таким же символом (т.е. писать `\\`), поскольку, как мы помним, обратный слэш используется в регулярных выражениях для указания управляющих символов.
___

<br>

# Свойства

+ `source` - собственно текст регулярного выражения
+ `ignoreCase` - логическое значение обозначающее наличие флага "i", доступно только для чтения
+ `global` - логическое значение обозначающее наличие флага "g",  доступно только для чтения
+ `multiline` - логическое значение обозначающее наличие флага "m",  доступно только для чтения
+ `lastIndex` - счетчик, указывающий, с какой позиции в строке начинать поиск

Свойство `sorce`

```JavaScript
let str = /fooBar/ig;
console.log(str.source);        // "fooBar"
```
<br>

Свойство `ignoreCase` указывает, использовался ли в определении регулярного выражения флаг `i`.

```JavaScript
let str = /fooBar/i;
console.log(str.ignoreCase);    // true
```

<br>

Свойство `global` указывает, использовался ли в определении регулярного выражения флаг "g". 

```JavaScript
let str = /fooBar/g;
console.log(str.global);        // true
```

<br>

Свойство `multiline` указывает, использовался ли в определении регулярного выражения флаг "m".

```JavaScript
let str = /fooBar/m;
console.log(str.multiline);     // true
```

<br>

Свойство `lastIndex` является целочисленным свойством регулярного выражения, доступным как для чтения, так и для записи, которое определяет индекс, с которого следует начинать следующее сопоставление.

Это свойство будет работать только если в регулярном выражении установлен модификатор `g`.

`lastIndex` возвращает целое число, которое обозначает позицию последнего символа найденного с помощью метода `exec` или `test`.

```JavaScript
//Определим произвольное регулярное выражение
let str = "Я короткая строка";
//Зададим регулярное выражение
let regexp = /о/g;

//Совершим глобальный поиск 'o' в строке текста и будем отображать
//позицию после каждого найденного совпадения
while (regexp.test(str)==true)
{
  console.log(regexp.lastIndex);
}
```
___

<br>

# Методы

+ `exec(text)` - выполнение поиска в строке, указанной в качестве параметра, возвращает массив найденных соответствий.
+ `test(text)` - проверка соответствия регулярному выражению, возвращает true\false.

Метод `exec() `выполняет регулярное выражение по отношению к строке-аргументу, результатом его работы является массив, в который попадают соответствия. Если соответствий не найдено, то результатом будет `null`. А если соответствие есть, то оно попадает в массив нулевым элементом, при этом свойство `lastIndex` объекта сместится на позицию, следующую непосредственно за найденной подстрокой.

### **Пример**

```JavaScript
var myString = "This is just a test text";  // Задаем строку для поиска
var myPattern = /te|is/g;                   // Задаем шаблон - либо "te" либо "is"

result = myPattern.exec(myString);          
console.log(result + ': ' + myPattern.lastIndex);   // "is: 4"

//result будет равен "is" - первому совпадению шаблона, свойство lastIndex примет значение 4

result = myPattern.exec(myString);      //result == "is" - второму совпадению шаблона, lastIndex == 7
console.log(result + ': ' + myPattern.lastIndex);   // "is: 7"
result = myPattern.exec(myString);      //result == "te" - третьему совпадению шаблона, lastIndex == 17
console.log(result + ': ' + myPattern.lastIndex);   // "te: 17"
result = myPattern.exec(myString);      //result == "te" - четвертому совпадению шаблона, lastIndex == 22
console.log(result + ': ' + myPattern.lastIndex);   // "te: 22"
```

В этом примере мы четыре раза подряд вызываем метод `exec()`, каждый раз он сдвигает указатель начала поиска на позицию, следующую за найденным совпадением и присваивает переменной `result` само найденное совпадение.

<br>

Метод `test()` выполняет регулярное выражение по отношению к строке-аргументу, результатом его работы является логическое значение - `true` если совпадение есть, и `false` если нет. Свойство `lastIndex` объекта также как и у метода `exec()` сместится на позицию, следующую непосредственно за найденной подстрокой.

> Важно! Если совпадение не найдено, то `lastIndex` будет смещен на позицию 0 и поиск можно будет начинать сначала.

### **Пример**

```JavaScript
var myString = "This is just a test text";  // Задаем строку для поиска
var myPattern = /te|is/g;                   // Задаем шаблон - либо "te" либо "is"

result = myPattern.test(myString);          
console.log(result + ': ' + myPattern.lastIndex);   // "true: 4"
//result будет равен true - первому совпадению шаблона, свойство lastIndex примет значение 4

result = myPattern.test(myString); //result == "true", lastIndex == 7
console.log(result + ': ' + myPattern.lastIndex);   // "true: 7"
result = myPattern.test(myString); //result == "true", lastIndex == 17
console.log(result + ': ' + myPattern.lastIndex);   // "true: 17"
result = myPattern.test(myString); //result == "true", lastIndex == 22
console.log(result + ': ' + myPattern.lastIndex);   // "true: 22"
result = myPattern.test(myString); //result == "false", lastIndex == 0
console.log(result + ': ' + myPattern.lastIndex);   // "false: 0"
```

В примере пять раз подряд вызываем метод `test()`, каждый раз он сдвигает указатель начала поиска на позицию, следующую за найденным совпадением и присваивает переменной `result` булево значение - `true` если совпадение найдено и `false` - если нет. В последнем запуске совпадение не найдено, поэтому указатель lastIndex получает значение 0.

___