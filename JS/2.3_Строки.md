# Работа со строковыми объектами

Создание объекта `String` можно выполнить тремя способами:

```JavaScript
+ myString = 'my string' //создание с помощью строкового литерала, тип myString будет "string"
+ myString = new String(object)  //создание объекта, тип myString будет "object"
+ myString = String(object)   //тип myString будет "string"
```

Такие объекты создаются **неявно**, строковым литералом: `var myString = 'Some text';`
> строковым литералы - любая последовательность символов, заключенная в любые кавычки

В строковом литерале можно использовать любые символы, а также **escape-последовательности**, если необходимо указать символ, который, например, нельзя набрать на клавиатуре. Выглядит это следующим образом:  `var myString = '\u1234';` где 1234 - номер знака в таблице юникода.
___

<br>

# Свойства объекта "String"

Слово "свойства" звучит слишком громко, стандартное свойство у него одно - длина. Обозначается оно словом `.length` и возвращает количество символов в строке.

```JavaScript
var cat = "Cat";
console.log(cat.length);    // 3 
```
___

<br>

# Методы объекта "String"

Методов у объекта `String` более чем достаточно. Рассмотрим их по группам:

**Методы доступа к символам объекта String:**  
Доступ к символам объекта String осуществляется двумя способами.

<u>**Основной**</u> - доступ через метод  `.charAt`

```JavaScript
var cat = "Cat";
console.log(cat.charAt(0));     // "C"
```

Этот код выведет в консоль символ с индексом 0 в строке - 'C'

Еще один метод, родственный предыдущему.
`charCodeAt(index)` - возвращает код символа в позиции `index`. Обращение к нему выглядит аналогично предыдущему методу, но на выходе мы юникод.

<u>**Второй способ**</u> доступа к символам - это **обращение к строке как к массиву**

```JavaScript
var cat = "Cat";
console.log(cat[0]);
```

> Важно! в отличие от большинства не скриптовых языков в JavaScript однажды созданную строку нельзя изменять, ее можно только считывать. Для изменения строки ее нужно полностью присваивать заново:
> ```JavaScript
> var cat = "Cat"; 
> cat = cat.charAt(2) + cat.charAt(1) + cat.charAt(0);      // taC
> ```
___

<br>

# Слияние и разделение строк

**`concat`**(string1, string2, ..., stringN) - объединяет строки

```JavaScript
var a = "первая строка";
var b = " вторая строка";
var c = " третья строка"; 
result = a.concat(b , c);

console.log(result);    // "первая строка вторая строка третья строка"
```

**`split`**('разделитель') - разделяет строки на массив подстрок по указанному разделителю

```JavaScript
var myString = "cat,dog,bird";
var myArray = myString.split(",");      // ["cat", "dog", "bird"]
```

Строка разбита по указанному нами разделителю (запятая), который при разделении в финальный массив не попадает.

У метода `split` есть еще один необязательный параметр - максимальное количество элементов в массиве. Все элементы больше указанного числа будут отброшены и в финальном массиве не появятся.

```JavaScript
var myString = "cat:dog:bird";
var myArray = myString.split(":" , 2);      // ["cat", "dog"]
```
___

<br>

# Преобразование регистра

`toLowerCase()` - преобразовывает все буквы в строке к нижнему регистру

`toUpperCase()` -  преобразовывает все буквы в строке к верхнему регистру

`toLocaleLowerCase()` -  преобразовывает все буквы в строке к нижнему регистру

`toLocaleUpperCase()` -  преобразовывает все буквы в строке к верхнему регистру

```JavaScript
var catName = "Kitty";
console.log (catName.toUpperCase());        // "KITTY"
```
___

<br>

# Возвращение части строки

`substring(indexA[, indexB])` - возвращает часть строки начиная с позиции **indexA**, но не включая **indexB**

`slice( indexA[, indexB] )` - возвращает часть строки начиная с позиции **indexA**, но не включая **indexB**

`substr(indexA[, length])` - возвращает часть строки начиная с позиции **indexA**, в количестве **length**

`replace(regexp, newSubString|function)`  - возвращает новую строку после замен, указанных в **regexp**, или функцию, которая ее возвращает.

> Параметр в квадратных скобках является необязательным.

В качестве примера разберем работу с методом  `substring(indexA[, indexB])`

```JavaScript
var myString = "Это просто строка!";
console.log(myString.substring(4, 17));     // "просто строка"
```

В результате в консоль будет выведен текст с 4 по 16-ю позиции

Различие между `substring` и `slice` – в том, как они работают с отрицательными и выходящими за границу строки аргументами:

+ substring(indexA[, indexB]) - Отрицательные аргументы интерпретируются как равные нулю. Слишком большие значения усекаются до длины строки:

```JavaScript
alert( "testme".substring(-2) );    // "testme", -2 становится 0
```

> Если **start > end**, то аргументы меняются местами, т.е. возвращается участок строки между **start** и **end**:
>```JavaScript 
> alert( "testme".substring(4, -1) );     // "test"
> // -1 становится 0 -> получили substring(4, 0)
> // 4 > 0, так что аргументы меняются местами -> substring(0, 4) = "test"
> ```

+ slice( indexA[, indexB] ) - Отрицательные значения отсчитываются от конца строки:

```JavaScript
alert( "testme".slice(-2) );    // "me", от 2 позиции с конца
alert( "testme".slice(1, -1) ); // "estm", от 1 позиции до первой с конца.
```

Если выбирать из этих трёх методов один, для использования в большинстве ситуаций – то это будет `slice`: он и отрицательные аргументы поддерживает и работает наиболее очевидно.
___

<br>

# Поиск подстроки в строке

`indexOf(searchValue[, fromIndex])` - ищет подстроку searchValue начиная с позиции fromIndex (аргументы, указанные в квадратных скобках не являются обязательными).

`lastIndexOf(searchValue[, fromIndex])` - ищет последнюю подстроку  searchValue начиная с позиции fromIndex ( поиск фактически будет в "обратную" сторону - т.е. первое вхождение от индекса fromIndex или конца строки в сторону начала строки)

`search(regExp)` - возвращает индекс первого сопоставления с регулярным выражением внутри строки. В противном случае метод вернёт -1.

`match(regExp)` - выдает массив всех совпадений с аргументом

<br>

разберем работу с методом `indexOf(searchValue[, fromIndex])`

```JavaScript
var myString = "Это просто проверочная строка!";
console.log(myString.indexOf("про", 0));    // 4
```

В консоль будет выведен номер позиции с которой начинается первая найденная подстрока  "про" - 4.

Однако, если укажем методу искать подстроку не с самого начала, а, например, с 5-й позиции:

```JavaScript
console.log(myString.indexOf("про", 5));    // 11
```

То тогда результат будет "11" - позиция, с которой начинается второе вхождение подстроки "про".

<br>

Метод  `lastIndexOf(searchValue[, fromIndex])` действует аналогично, но возвращает номер, с которого начинается последнее вхождение искомой подстроки. `fromIndex` обозначает место, с которого нужно начинать поиск по направлению к началу строки, его значение по-умолчанию - **длина строки**. 

```JavaScript
var myString = "Это просто проверочная строка!";
console.log(myString.lastIndexOf("про"));
```
в консоль будет выведена цифра 11 - начало последнего вхождения подстроки "про".
___

<br>

# Преобразование типов

`fromCharCode(num1, num2,...,numN)` - создает элементарную строку из значений символов **Юникода**.

Например, выражение  `myString = String.fromCharCode(65, 66, 67);`  присвоит переменной `myString` значение "ABC".

`toString()` - возвращает элементарную строку вместо объекта String

`valueOf()` - возвращает элементарную строку вместо объекта String, эквивалентно `toString()`. 
В результате выполнения приведенного ниже кода в консоль будет выведено элементарное значение.

```JavaScript
myString = new String("Hello world");
console.log(myString.valueOf());
```
___




